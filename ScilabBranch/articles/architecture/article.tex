\documentclass[a5paper]{article}
\usepackage[a5paper, top=17mm, bottom=17mm, left=17mm, right=17mm]{geometry}
\usepackage[cp1251]{inputenc}
\usepackage[T2A,T1]{fontenc}
\usepackage[colorlinks,filecolor=blue,citecolor=green,unicode,pdftex]{hyperref}
\usepackage{cmap}
\usepackage[english,russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb,amsfonts,textcomp}
\usepackage{color}
\usepackage{array}
\usepackage{hhline}
\hypersetup{colorlinks=true, linkcolor=blue, citecolor=blue, filecolor=blue, urlcolor=blue, pdftitle=1, pdfauthor=, pdfsubject=, pdfkeywords=}
% \usepackage[pdftex]{graphicx}
\usepackage{graphicx}
% Раскомментировать тем, у кого этот пакет есть. Шрифт станет заметно красивее.
% \usepackage{literat}
\usepackage{indentfirst}

\sloppy
\pagestyle{plain}
%\pagestyle{empty}

\title{Архитектура среды визуального моделирования QReal}

\author{А.Н. Терехов \and Т.А. Брыксин \and Ю.В. Литвинов \and К.К. Смирнов \and Г.А. Никандров \and В.Ю. Иванов \and Е.И. Такун}
\date{}
\begin{document}

\maketitle
\thispagestyle{empty}

\begin{quote}
\small\noindent
Существует довольно много программных средств визуального моделирования, однако часто
появляется необходимость создать новый графический редактор или даже 
целую CASE-систему для какой-либо специальной предметной области. 
Разработка таких систем, несмотря на имеющиеся в этой области технологии 
(Microsoft DSL Tools, Eclipse/GMF и т.д.), продолжает оставаться трудоемкой 
и сложной задачей. Существует недостаток в описаниях подходов и принципов 
реализации таких средств, существующие источники 
немногочисленны и часто носят общий, поверхностный характер, либо 
полезная информация <<растворена>> в большом 
количестве технических деталей реализации. Таким образом, описание опыта 
разработки средств визуального моделирования и обсуждение различных вариантов их 
реализации представляется актуальной и важной задачей. В работе описана 
архитектура системы QReal, являщейся MetaCASE-пакетом и включающей 
реализацию основных типов диаграмм UML 2.1 и некоторых других диаграмм. 
Система поддерживает многопользовательскую работу, является распределенной и многоплатформенной.
\end{quote}

\section*{Введение}
В настоящее время для разработки программного и аппаратного обеспечения довольно активно используется 
визуальное моделирование. Для автоматизации процесса разработки используются CASE-средства, в которых 
разрабатываемая система представляется в виде модели на каком-либо визуальном языке программирования. 
Широкое распространение получил язык UML~\cite{umlInfrastructure}\cite{umlSuperstructure}, для различных предметных
областей создаются специализированные языки, такие как BPMN~\cite {bpmn}, IDEF*~\cite{idef} и др.

Существует множество CASE-пакетов, реализующих различные подмножества или варианты языка UML и другие 
визуальные языки. Такие пакеты существуют для различных платформ, поддерживают различные процессы и методологии 
разработки, предназначаются для различных целей\footnote{Списки существующих CASE-пакетов можно найти здесь:
http://www.objectsbydesign.com/tools/umltools\_byCompany.html 
или http://en.wikipedia.org/wiki/List\_of\_UML\_tools.}. 
Средства визуального моделирования часто встраиваются в текстовые средства разработки
(например, различные визуальные редакторы в составе Microsoft Visual Studio, редактор UML-диаграмм в среде 
NetBeans\footnote{http://www.netbeans.org/features/uml/.} и т.д.). 
Тем не менее, зачастую возникает необходимость создавать специализированные 
CASE-средства, предназначенные для какой-либо узкой предметной области --- 
см., например, обсуждение в работах~\cite{koznov, koznovDsl, amln}.

Сложность разработки CASE-пакетов довольно велика, поскольку приходится решать 
проблемы эффективной реализации 
редакторов диаграмм, организации хранения и оперативного доступа к большим 
объёмам данных 
со сложной структурой, поддержки процесса разработки программного обеспечения, 
включая 
многопользовательскую работу, версионирование и т.д. 
Необходимо также обеспечить <<сквозной>> характер всей технологии в целом: 
реализовать генерацию кода по 
визуальным моделям, поддержать процедуру внесения <<ручных>> изменений в 
сгенерированный по моделям программный код, обеспечить 
согласованность и корректность всех диаграмм  на всех этапах разработки.

Существующие технологии и средства 
разработки специализированных CASE-пакетов, такие как Eclipse GMF~\cite{eclipseGmf}
и Microsoft DSL Tools~\cite{msDslTools}, обладают рядом недостатков,
делающих их широкое использование затруднительным: GMF громоздок и довольно сложен в использовании,
DSL Tools удобен для реализации только несложных языков и привязан к среде Visual Studio.
Поэтому варианты эффективной реализации перечисленных выше свойств CASE-систем
нуждаются в обсуждении, аргументации принятия тех или иных решений,
разработке архитектурных шаблонов. Все это, на наш взгляд, представляет интерес сообществу 
разработчиков CASE-систем, разработчиков и пользователей отдельных графических 
редакторов вне зависимости от того, 
будут ли они пользоваться представленной в статье системой QReal или нет.  

В настоящей работе представлена архитектура системы QReal --- MetaCASE-системы
для создания визуальных редакторов. Кроме мета-средств эта 
система включает в себя также реализацию редакторов для основных диаграмм UML 2.1 и некоторых 
других видов диаграмм. Кроме того, QReal будет включать в себя генераторы
форм ввода/вывода, схем баз данных и исполняемого кода для различных платформ,  
распространяемые на коммерческой основе.

Система QReal обладает следующими особенностями.
\begin{itemize}
  \item Многоплатформенность --- возможность перекомпиляции исходного кода всей системы
     для разных целевых операционных систем. Для обеспечения кроссплатформенности использовался 
     инструментарий для создания кроссплатформенных приложений Qt~\cite {qt}.
     На данный момент поддерживаются платформы Windows и Linux,
     сборка продукта возможна на всех платформах, поддерживаемых библиотекой Qt (Windows, Mac OS, Linux/X11, 
     embedded Linux, Windows CE и S60, в будущем --- QNX и VxWorks).
  \item Распределенность:
  \begin{itemize}
     \item возможность удаленного доступа к общему репозиторию;
     \item наличие системы разграничения прав конкурентного доступа.
  \end{itemize}
  \item Реализация генеративного подхода к созданию новых графических 
     редакторов, позволяющего создавать редакторы диаграмм для 
     специализированных визуальных языков, не прибегая к программированию.
  \item Распространение всей системы под лицензией GPLv2, то есть
     независимость от закрытых, проприетарных библиотек, технологий и 
     средств разработки.
\end{itemize}

Далее в статье приводится подробное обсуждение этих особенностей, описание 
выявленных трудностей и обоснование принятых технических решений.

\section{Существующие решения}

Системы визуального моделирования делятся на две группы --- универсальные 
и предметно-ориентированные системы~\cite{koznov}. Универсальные CASE-пакеты
не имеют какой-либо специализированной ориентации и поддерживают
визуальные языки общего назначения (как правило, UML). Такие пакеты
являются коробочными и довольно широко представлены на рынке.
Наиболее известные из них --- 
Enterprise Architect\footnote{http://www.sparxsystems.com.au/.}, 
IBM Rational Rose\footnote{http://www-01.ibm.com/software/awdtools/developer/rose/.},
Microsoft Visio\footnote{http://office.microsoft.com/ru-ru/visio/FX100487861049.aspx.}, 
Visual Paradigm\footnote{http://www.visual-paradigm.com/product/vpuml/.}. 
Как правило, универсальные CASE-пакеты имеют открытые программные интерфейсы, позволяющие
расширять их функциональность. Чрезмерная универсальность
таких средств делает их применение на всех этапах разработки менее
выгодным по сравнению с предметно-ориентированными средствами.

Предметно-ориентированные системы предназначены для определённой
предметной области, достаточно узкой, чтобы обеспечить
наибольшую выгоду от применения визуального моделирования
и обеспечить эффективную генерацию кода. Такие инструменты
могут разрабатываться компаниями для своих внутренних нужд,
для решения задач именно того процесса, для поддержки которого
они создаются. Для облегчения реализации предметно-ориентированных 
визуальных языков
существуют MetaCASE-технологии, такие как Eclipse GMF, Microsoft DSL Tools, 
MetaEdit+ ~\cite{metaEdit+} 
В современных  CASE-системах, таких как GME\footnote{http://www.isis.vanderbilt.edu/Projects/gme/.},
Rational Software Architect\footnote{http://www-01.ibm.com/software/awdtools/swarchitect/.}) 
имеются также средства настройки, позволяющие пользователю 
описывать свои визуальные языки и относительно легко реализовывать 
их поддержку. 

\subsection{Инструментарий Microsoft DSL Tools}

Инструментарий Microsoft DSL Tools является частью среды разработки Visual Studio
и предназначен для создания встроенных в Visual Studio визуальных редакторов. Процесс
создания нового редактора состоит из описания метамодели языка на
специальном визуальном языке DSL Tools, генерации редактора и внесения
в сгенерированный код ручных изменений для реализации дополнительной функциональности,
такой как валидация моделей. Сохранение ручных изменений после перегенерации
редактора осуществляется за счёт использования частичных классов (partial classes) .Net.

Язык описания метамоделей состоит из доменных классов (domain classes), которыми задаются
отдельные сущности проектируемого языка, отношения ассоциации, агрегирования и
наследования (следует отметить, что отношение в DSL Tools может иметь атрибуты и
представляется, по сути, классом), а также средств задания нотации --- геометрических фигур 
и свойств линий для отношений. Процедуры отрисовки недостающих графических примитивов 
можно реализовать самостоятельно на C\#.

DSL Tools хорошо подходит для реализации несложных предметно-ориентированных языков,
которые будут использоваться внутри среды Visual Studio, однако независимый графический 
редактор с помощью DSL Tools создать невозможно. Реализация сложных визуальных
редакторов с возможностями, не поддерживаемыми DSL Tools изначально, как правило,
требует больших объёмов кодирования на C\#.

\subsection{Технология Eclipse GMF}

Технология Eclipse GMF (Graphical Modelling Framework) создана на базе
среды разработки с открытыми исходными кодами Eclipse. GMF предназначена
для быстрой разработки графических редакторов, в основном, интегрируемых в
Eclipse, и построена на двух широко используемых библиотеках --- Eclipse
Modeling Framework (EMF) и Graphical Editing Framework (GEF). Архитектура
построенного с помощью GMF пакета основана на шаблоне проектирования 
Model/View/Controller (MVC), где для создания моделей используется EMF,
а для создания представлений и контроллеров используется GEF.

Процесс создания визуальных редакторов в GMF состоит из следующих шагов.
\begin{itemize}
  \item Разработка доменной модели --- абстрактного синтаксиса разрабатываемого
    предметно-ориентированного языка. Доменная модель может быть разработана
    с помощью графического редактора Ecore (входящего в состав GMF), импортирована
    из XMI\footnote{XML Metadata Interchange, стандарт OMG для обмена метаданными, http://www.omg.org/technology/documents/formal/xmi.htm}-документа, 
    из набора аннотированных Java-интерфейсов или из XML-схемы.
  \item Разработка графической модели --- описания графической нотации разрабатываемого языка.
  \item Разработка модели инструментов --- описания элементов панели инструментов.
  \item Разработка модели соответствия --- связи между тремя предыдущими моделями.
  \item Создание модели генератора --- промежуточного представления разрабатываемого
    редактора. Эта модель автоматически генерируется по модели соответствия и дополняется
    <<вручную>>.
  \item Генерация целевого визуального редактора.
\end{itemize}

Данная технология позволяет создавать независимые от Eclipse графические редакторы,
однако, на наш взгляд, довольно сложна в использовании и громоздка.

\subsection{Rational Software Architect}

IBM Rational Software Architect --- развитие широко известной 
CASE-системы Rational Rose.
Этот инструмент представляет из себя полноценную среду разработки и предназначен прежде 
всего для проектирования с использованием UML 2.0, имеет развитые средства генерации 
кода и возвратного проектирования для языков Java и C++. К наиболее интересным особенностям 
этого инструмента можно отнести следующие:
\begin{itemize}
  \item автоматический поиск архитектурных паттернов и антипаттернов в моделях;
  \item возможность определять свои паттерны проектирования и шаблоны генерации кода;
  \item возможность автоматически следить за целостностью архитектуры разрабатываемого приложения,
    поддержание стиля кодирования;
  \item поддержка трассируемости, инструменты для отслеживания связи требований с реализацией;
  \item поддержка многопользовательской работы, интеграция с системами контроля версий.
\end{itemize}

Rational Software Architect может использоваться и как платформа для реализации
предметно-ориентированных визуальных языков. Сам этот CASE-пакет является расширением среды
Eclipse и построен с использованием технологии GMF, что делает возможным использование
возможностей Eclipse для написания плагинов. Кроме того, сам Software Architect 
имеет средства определения профилей UML, произвольных предметно-ориентированных языков (с версии 7.5),
а также возможность использования любых их комбинаций. 
Независимый редактор таким способом построить нельзя.

\subsection{Технология REAL}

CASE-пакет QReal является развитием идей технологии \mbox{REAL}~\cite{real1, real2}, 
разработанной на кафедре системного программирования математико-механического 
факультета Санкт-Петербургского государственного университета. 
REAL является технологией разработки информационных систем и
систем реального времени и представляет собой набор взаимосвязанных
графических редакторов диаграмм UML 1.4 и SDL-92 ~\cite{sdl}
-диаграмм, объединенных в единую среду разработки.  На его основе был создан 
набор
технологических решений для различных областей, например, REAL-IT для 
автоматической генерации 
по моделям информационных систем, интенсивно работающих с данным  ~\cite{realIt} 

Решение о разработке нового CASE-пакета было принято по следующим соображениям.

\begin{itemize}
  \item Набор визуальных языков, поддерживаемых системой \mbox{REAL}, устарел с появлением
        UML 2.0.
  \item Процесс добавления нового редактора в систему происходил кодированием на
        языке C++ (пусть даже и с учетом факта переиспользования компонент), 
        что кажется нам весьма неоптимальным. К тому же, добавление нового редактора 
        требовало от разработчиков знания архитектуры CASE-пакета в целом.
  \item Реализация графово-графической библиотеки CASE-пакета основана
        на устаревшей библиотеке MFC, что усложняет задачу сопровождения продукта
        и перенос на другие платформы.
\end{itemize}

Была предпринята попытка модификации отдельных модулей
REAL (сначала графово-графической библиотеки, а потом и репозитория) с целью устранения указанных
недостатков, однако быстро стало ясно, что осуществление подобного рода
масштабирования и расширения системы неосуществимо, если возможности
для этого не были учтены при изначальном проектировании архитектуры
приложения в целом.

\subsection{Выводы}

Разработка новой CASE-системы общего назначения (поддерживающей язык UML
и генерацию в достаточно широкий класс систем, например, веб-приложения) на данный момент
представляется нам задачей, вероятность возникновения которой крайне низка ---
большое количество довольно качественных систем такого типа представлено на рынке, 
с различной функциональностью и в разных ценовых категориях. Однако же, такие
системы не предназначены для разработки пользовательских визуальных языков,
редакторов и генераторов к ним. 

Поскольку задача создания предметно-ориентированных визуальных языков
возникает всё чаще, необходимо иметь возможность быстро создавать CASE-системы
для их поддержки. Такие CASE-системы, как нам кажется, не могут быть коробочными, поскольку 
сами языки и требования к генераторам, редакторам и т.д. могут сильно отличаться
не только в разных компаниях, но и в разных проектах в рамках одной компании.
Microsoft DSL Tools и Eclipse GMF --- примеры инструментария для быстрой
разработки таких CASE-систем, однако они, по нашему мнению, обладают некоторыми 
недостатками. Первый из них прост в использовании, но позволяет создавать только 
графические редакторы, которые являются неотъемлемой частью среды Microsoft 
Visual Studio. Кроме того, в Microsoft DSL Tools сложно реализуются 
нестандартные графические нотации. 
Eclipse GMF существенно более универсален --- Rational Software Architect 
может послужить примером
того, что можно сделать с помощью Eclipse GMF, но  и существенно более сложен в
использовании. Вместе с тем для этого инструментария почти нет доступной 
документации, и ознакомиться с его функциональными возможностями и 
особенностями реализации можно, только самостоятельно выполнив значительный 
проект с использованием этой технологии.

\section{Основные концепции QReal}

Система QReal имеет архитектуру <<клиент-сервер>> и основывается на 
шаблоне проектирования Model/View. Каждый клиент имеет свою модель, которая 
обеспечивает доступ к репозиторию, а в роли представлений выступают 
различные элементы пользовательского интерфейса.

Следует пояснить, почему был выбран именно шаблон Model/View,
а не более общий шаблон Model/View/Controller --- иначе функциональность
контроллера брала бы на себя логику графических редакторов, что 
не очень удобно, поскольку редакторы в системе QReal генерируются, а не
программируются <<вручную>>. Разнесение функциональности редакторов по разным
модулям усложнило бы генерацию, не предоставив существенных преимуществ. 
Данное решение детально описано в ~\cite{bryksin}.

Общая архитектура системы изображена на рисунке \ref{qRealArchitecture}. 
Для обеспечения версионирования и многопользовательской работы используется 
SVN\footnote{http://subversion.tigris.org/.}-сервер. Доступ к нему осуществляется посредством клиентов репозитория, которые хранят свои модели в виде файлов,
организованных в рабочую копию системы контроля версий. Генераторы могут быть встроенными
в клиентскую часть CASE-пакета (например, генератор XMI) или работать независимо. В таком
случае им потребуется компонента, отвечающая за взаимодействие с SVN-репозиторием и
представление модели в памяти. Общение с ней ведётся по протоколу ICE~\cite{ice}, что
позволяет реализовывать генераторы на различных языках программирования.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=\textwidth, bb=0 0 798 531]{qRealArchitecture.png}
    \caption{Архитектура QReal}
    \label{qRealArchitecture}
  \end{center}
\end{figure}

\subsection{Графический интерфейс}

Графический интерфейс CASE-пакета обычно содержит вполне определенный набор элементов. В
QReal они представлены следующими компонентами (см. рис.~\ref{mainWindow}).

\begin{itemize}
  \item \textit{Инспектор объектов (Object Explorer).} Представляет
        собой дерево объектов текущего проекта CASE-пакета, содержащее все элементы в открытом в данный
        момент репозитории, отсортированные по их типам. Бывает
        удобен для обзора проекта в целом и при добавлении на текущую диаграмму 
				уже существующего в проекте объекта, например, не принадлежащего никаким диаграммам.
  \item \textit{Инспектор диаграмм (Diagram Explorer).} Отображает все
        пользовательские диаграммы и элементы на них в виде дерева. Один элемент
        может принадлежать нескольким диаграммам, тогда в
        инспекторе он будет отображаться как потомок всех диаграмм, которым он
        принадлежит (в инспекторе объектов и в репозитории всем этим <<копиям>>
        будет соответствовать один элемент).
  \item \textit{Редактор свойств (Property Editor).} Предоставляет информацию о выделенном 
        элементе и позволяет изменять значения его атрибутов.
  \item \textit{Палитра компонентов.} Отображает все возможные для добавления на
        диаграмму визуальные элементы.
  \item \textit{Меню, панели инструментов.} Содержат основные операции над репозиторием, 
        диаграммами, объектами и т.д.
  \item \textit{Рабочая область графического редактора диаграмм}. Основная
        рабочая область CASE-пакета. Здесь осуществляется отображение и 
	модификация создаваемых пользователем диаграмм. 
\end{itemize}

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=\textwidth, bb=0 0 1280 948]{draft04-img1.png}
    \caption{Главное окно QReal}
    \label{mainWindow}
  \end{center}
\end{figure}

Следует заметить, что реализация подобного рода элементов графического
интерфейса, как правило, является платформо-зависимой задачей, т.е.
требует использования системных графических библиотек, что противоречит
требованию многоплатформенности. Известно несколько способов решения задач такого
рода.

\begin{itemize}
  \item Использование переносимости на уровне бинарного кода, например, байт-код Java. 
		Java-приложения могут работать на любом устройстве, для которого существует 
		реализация виртуальной машины.
  \item Переносимость приложения на уровне исходных кодов. Это достигается путем
		использования многоплатформенных инструментариев, инкапсулирующих в себе 
		реализацию базовых графических примитивов для различных операционных систем. Библиотеки
		подобного рода предоставляют единый интерфейс для работы с ними вне
		зависимости от используемой операционной системы. 
		Наиболее распространенными готовыми решениями в данной области
		являются инструментальные средства Qt и GTK+.
\end{itemize}

Основным достоинством первого подхода является отсутствие необходимости перекомпиляции, что
не очень существенно для CASE-систем, поскольку отношение времени компиляции исходных кодов 
к общему времени работы с продуктом невелико. Достоинством второго подхода является более
высокая производительность, что при работе с большими моделями может быть достаточно важно.

В процессе разработки архитектуры и реализации прототипов модулей CASE-пакета было решено
использовать инструментарий Qt. Этот выбор показался нам удачным по 
следующим причинам.

\begin{itemize}
  \item Qt --- динамически развивающийся проект, за время работы над прототипом
        было выпущено несколько новых версий этого инструментария,
        каждая из которых существенно расширяла возможности предыдущей.
  \item Если Qt первых версий рассматривалась разработчиками как графическая библиотека, то 
  			начиная с версии 4 это полноценный инструментарий для разработки 
  			многоплатформенных приложений. Помимо элементов графического интерфейса 
  			он включает в себя классы для работы с сетью, базами данных, XML и многое другое.
  \item В Qt с версии 4 входит Qt Model/View Framework, который 
        предоставляет для использования набор готовых реализаций стандартных
        моделей и представлений и возможность быстро создавать новые.
  \item Распространение с версии 4.5 под лицензией LGPL, что даёт возможность
				использовать Qt в коммерческих приложениях.
  \item Перспективы развития инструментария, например, портирование QReal средствами
	      Qt в веб-приложение.
\end{itemize}

\subsection{Репозиторий на основе реляционной СУБД}

Репозиторий является ответственным за хранение данных и предоставление интерфейсов доступа к ним для других компонент. 
В QReal репозиторий организован в соответствии с архитектурой клиент/сервер, где клиентская часть встраивается в сам CASE-пакет, а серверная
размещена удалённо. Серверная составляющая может быть реализована:
\begin{itemize}
  \item на основе стандартных средств версионного контроля (например, CVS, Visual SourceSafe или Subversion);
  \item в виде хранилища данных с помощью набора плоских файлов;
  \item как надстройка над реляционной СУБД.
\end{itemize}

Последний вариант сначала показался нам наиболее удачным, к тому же он уже применялся в системе REAL.

Сравнивая подход, используемый QReal, и подход к хранению репозитория в СУБД в REAL~\cite{kondratyev}, необходимо отметить некоторые различия.
При проектировании БД репозитория REAL использовался подход, использующий идеи  
стандарта объектно-ориентированных баз данных ODMG~\cite{odmg}, в то время как 
в QReal использовался оригинальный
подход, направленный на увеличение быстродействия в условиях низкоскоростных 
сетей. В результате этого схема БД получилась иной. Основная
информация о поддерживаемых типах вместе с уникальными идентификаторами 
типов хранится в таблице \textit{metatable}. Все существующие в репозитории элементы
перечислены в таблице \textit{nametable} вместе со своими уникальными идентификаторами, типом и теми свойствами, которые являются общими для всех элементов
(например, имени). Размещение таких свойств в этой таблице позволяет ускорить доступ, особенно для стандартных представлений инструментария Qt. Помимо
этого, есть одна большая таблица \textit{diagram}, которая содержит данные о потомках объекта, в частности, о содержимом диаграмм. В данной схеме не только
диаграммы содержат внутри себя объекты: в частности, пакеты тоже могут содержать классы в качестве дочерних элементов. В таблице содержится
идентификатор
родительского элемента, идентификатор дочернего элемента и параметры, отвечающие за отображение объекта на данной диаграмме (координаты, размеры,
конфигурацию ломаной линии, и т.д.). Помимо этого, как и в реализации репозитория REAL, существуют и таблицы по одной на каждый тип элемента, в которых хранятся
свойства, специфичные для каждого типа элементов. Но в QReal все специфичные свойства конкретного элемента находятся в одной таблице, а в REAL они
разнесены и по таблицам родителей. Следует отметить, что в реализации REAL более четко проработана реализация целостности репозитория, которая
обеспечивалась средствами СУБД, что не было сделано в QReal в связи с переходом на другую систему репозитория.

Также необходимо отметить и некоторые архитектурные особенности построения. В системе REAL доступ к репозиторию из сторонних приложений осуществляется
посредством интерфейса COM и средствами VBScript, что привязывает систему к ОС семейства Windows. Программный интерфейс C++ используется только самими
редакторами и недоступен другим приложениям. В системе QReal интерфейс на C++ полностью открыт на уровне логической модели и может использоваться
другими системами, а в качестве скриптового языка был предложен язык на основе EcmaScript (т.н. JavaScript), однако систему скриптования еще предстоит доделать.

В качестве системы доступа к БД очевидным способом были выбраны средства Qt, что позволило использовать и клиент, и сервер на любой платформе, причем
для многих из серверов отпадала необходимость в ODBC-прослойке.

Более подробное описание схемы базы данных можно найти в дипломной работе Никандрова Г.~\cite{nikandrov}.

\subsection{Генеративный подход к созданию редакторов}

CASE-пакет --- это система визуального моделирования, в состав которой входит определенное число
графических редакторов. И будь то редакторы бизнес-процессов, схем баз
данных, компонент программного обеспечения или структуры организаций,
по своему внутреннему устройству они будут довольно похожи.

Редактор инкапсулирует в себе информацию о наборе объектов, допустимых
на диаграммах данного типа, и должен быть способен правильно
интерпретировать хранящиеся в репозитории значения атрибутов элементов
(например, использовать некоторые из них как параметры при
отрисовке). Кроме того, редактор должен иметь представление о логических правилах размещения
элементов на соответствующих типах диаграмм (например, возможность
соединять некоторые элементы ассоциациями, возможность одних элементов
быть контейнерами для других и т.д.).

Создавать набор таких редакторов кодированием их <<вручную>> кажется нам
неразумным по следующим причинам:

\begin{itemize}
  \item с ростом числа редакторов значительно снижается сопровождаемость кода;
  \item слабая расширяемость --- добавление новой функциональности требует
        изучения (а нередко и существенного рефакторинга) уже существующего
        кода;
  \item опасная масштабируемость --- создание дополнительного редактора,
        являющегося типовым для данного CASE-средства, чаще всего будет
        осуществляться методом Copy/Paste с
        дальнейшими доработками полученного после копирования текста, что ведёт как к
        появлению новых ошибок, связанных с неполнотой вносимых
        правок, так и к размножению уже существующих;
  \item происходит неизбежное усложнение внутреннего устройства модуля
        редакторов, и, как следствие, усложнение архитектуры
        CASE-пакета в целом.
\end{itemize}

В соответствии с этим был предложен следующий подход к автоматическому
созданию графических редакторов:

\begin{itemize}
  \item путем анализа типовых редакторов выделяется базовая функциональность
        абстрактного редактора, которая кодируется <<вручную>> на целевом языке
        высокого уровня (в нашем случае, на C++);
  \item специфика метамоделей нужных диаграмм (или наиболее полное их подмножество) 
        описывается с помощью специального XML-формата;
  \item по этим описаниям генерируется C++ код,
        который в совокупности с базовой функциональностью полностью реализует
        требуемую функциональность описанных диаграмм.
\end{itemize}

В CASE-пакете QReal была реализована следующая инфраструктура:

\begin{itemize}
  \item <<ядро>>, обеспечивающее функциональность абстрактного редактора (реализовано вручную):
    \begin{itemize}
      \item способность элементов принадлежать диаграммам (в том числе, способность
            одного элемента принадлежать неограниченному числу диаграмм);
          \item способность получать значения нужных атрибутов из репозитория и
            отслеживать изменения его содержимого;
          \item способность элементов отрисовываться в пределах рабочей области
            диаграммы;
          \item способность ассоциаций соединять элементы и способность элементов
            присоединять к себе ассоциации;
          \item способность абстрактного элемента быть контейнером для других;
          \item способность элемента реагировать на действия пользователя (например, на
            выделение курсором мыши, перемещение, изменение размеров) и т.п.
    \end{itemize}
  \item наследуемые от <<ядра>> классы, определяющие специфику конкретных типов
        диаграмм (генерируются автоматически по XML-описаниям):
        \begin{itemize}
          \item набор допустимых для каждого конкретного типа диаграмм элементов;
          \item графические представления и параметризация их значениями атрибутов
                этих элементов;
          \item стиль начертания ассоциаций, форма и тип возможных стрелок;
          \item логические правила, специфичные для данного типа диаграмм (например,
                правила соединения элементов ассоциациями) и т.п.
        \end{itemize}
\end{itemize}

Необходимый для описания метамоделей диаграмм формат должен обладать
следующими возможностями:

\begin{itemize}
  \item задание графического представления элемента в текстовом виде (для
        элементов) или способа начертания линий и задания формы и типа стрелок
        (для ассоциаций);
  \item задание параметризации статического изображения элемента содержимым
        репозитория (например, отображение имени элемента);
  \item описание набора атрибутов элементов: поддержка как основных типов данных
        (строки, числа, логический тип, перечисление), так и возможность
        создания пользовательских;
  \item указание факта наследования элементов;
  \item описание логики ассоциаций: задание для каждого конца ассоциации набора
        допустимых для соединения с ним элементов, задание атрибутов ассоциаций
        (например, множественности или метки) и т.п.
\end{itemize}

Формат должен основываться на XML и иметь
простую структуру. Тогда создание новых редакторов или внесение
изменений в уже существующие не требует ни навыков программирования, ни
знания внутреннего устройства всего CASE-пакета и может осуществляться
пользователями напрямую.

Формат, обладающий описанными характеристиками и используемый в QReal, подробно 
описывается в  работе ~\cite{simonova}.

\subsubsection{Генерация редакторов по метамодели}

Процесс генерации редакторов в системе QReal организован так:
созданные описания метамоделей подаются на вход специальной
утилите-генератору, которая осуществляет анализ предоставленных ей
XML-документов, в результате чего для каждой сущности (как для элемента, 
так и для ассоциации) определяется список свойств с указанием их типа, 
список родительских элементов (сущность может наследовать свойства и логику
родительских элементов), отображаемое имя сущности и т.д.

Дополнительно сущности, представляющие вершины графа логической модели, имеют секцию описания
их графического представления (в первых версиях для его задания использовался язык SVG). 
Это описание сохранялось в виде файла на диске и использовалось как для отрисовки элементов 
в рабочей области редактора диаграмм, так и для создания иконок для палитры компонентов, 
инспектора объектов и диаграмм. Изображения, описанные на языке SVG, являются статичными, 
поэтому для их параметризации содержимым репозитория (например, для отрисовки имени элемента) 
используется специальная XML-секция. Для этого используются расширенные соответствующим образом
HTML-теги, поскольку инструментарий Qt предоставляет классы для интерпретации
и отрисовки основных тегов HTML~\cite{htmlInQt}. Таким образом
обеспечивается форматирование подставляемых из репозитория
значений. В ходе разбора соответствующих секций XML-описаний генератор заменяет теги
параметризации соответствующим C++ кодом для
получения нужных значений атрибутов элемента, при этом теги
форматирования текста сохраняются. Во время выполнения полученного кода 
произойдет обращение к репозиторию, и значение атрибута будет отображено в рабочей
области редактора поверх статичного SVG-изображения элемента.

Здесь следует указать на то, что использование формата SVG, как и любого другого
графического формата общего назначения, позволяет реализовать только
самые простые редакторы, поскольку в развитом CASE-средстве
графические элементы могут обладать достаточно сложным поведением, не выразимым
ни статическим, ни параметризованным изображением. Представляется, что CASE-средства
должны иметь специализированный формат задания графических элементов. В системе
QReal от использования формата SVG в результате пришлось отказаться, хотя общий
принцип наличия секции с графическим представлением элементов в XML-описаниях
был сохранён. Самым простым примером невыразимого в SVG аспекта отрисовки
элементов являются порты.

Порты --- это области графического отображения элемента, к которым возможно присоединение ассоциаций.
Формат (а следовательно, и генератор) поддерживает задание портов двух
типов --- точка и отрезок (в случае последнего ассоциация может быть
прикреплена к любой точке отрезка). Вся функциональность по обработке
присоединения к портам и адекватного отображения ассоциаций при
изменении размера/движении элемента реализована в ядре редактора, в генерируемых классах
конкретных элементов достаточно лишь указать тип и расположение порта.

Для сущностей, представляющих рёбра графа модели, для каждого из концов 
ассоциации указывается набор типов
элементов, к которым она может быть прикреплена, тип начертания линии 
ассоциации при ее визуальном отображении, формы и стиля закраски
стрелок, например, задание обычных стрелок и стрелок в
виде ромба (как закрашенные, так и нет для обоих вариантов).

После разбора XML-описаний метамоделей производится построение набора свойств
сущностей (с учетом наследования элементов), списка возможных для присоединения элементов 
ассоциаций (для каждого из концов), проверяется ссылочная целостность, выполняются
другие проверки семантической корректности описаний редакторов.

В ходе заключительной фазы происходит генерация необходимых артефактов, а именно, создаются:

\begin{itemize}
  \item классы на языке C++ для всех элементов и
        ассоциаций диаграмм;
  \item файлы с описаниями графического представления элементов;
  \item внутренние средства доступа к значениям атрибутов элементов в
        репозитории из любых модулей проекта.
  \item дополнительный код для присоединения генерируемых классов к проекту. В
        него входят фабрика объектов для создания экземпляров описанных типов
        элементов и ассоциаций, а также служебные файлы --- файл ресурсов проекта
        и файл, осуществляющий включение генерируемых файлов с классами
        описанных сущностей в процесс сборки проекта.
\end{itemize}

Подробнее генератор редакторов описан в  работе ~\cite{bryksin}.

\section{Дальнейшее развитие}
\subsection{Смена способа хранения данных}

После создания и апробации первого работающего прототипа
системы QReal были сформированы основные замечания к нему.

\begin{itemize}
  \item Использование реляционной СУБД в качестве сервера репозитория 
        затрудняет оповещение подключенных клиентов об изменении хранимых
        данных.
  \item Состав  хранимых на сервере данных определялся схемой текущей базы
        данных, которая генерировалась по описаниям метамоделей. В
        результате, если несколько клиентов имели бы разный набор редакторов (или,
        что еще хуже, разные версии одних и тех же редакторов), то работа с
        ними сопровождалась бы большим количеством ошибок, содержимое
        репозитория с большой вероятностью было бы испорчено.
  \item Неэффективность некоторых типов запросов (упреждающая загрузка,
        отложенное чтение) и кэширования.
\end{itemize}

Все эти проблемы могли бы быть устранены либо расширением клиента
репозитория (реализацией механизма опроса, хранением дополнительной
информации о редакторах и проверкой ее в клиенте перед началом работы
и т.п.), либо введением некой программной <<прослойки>> между клиентом
репозитория и СУБД, в которую можно было бы вынести всю необходимую
дополнительную функциональность.

Анализ этих и некоторых других замечаний к существующему решению дал
понять, что хотя выбранный при создании прототипа системы подход
построения репозитория на основе реляционной СУБД позволил в сжатые
сроки получить большую частью требуемой функциональности, в перспективе
потребуется его существенная доработка. 

В итоге было принято решение о реализации собственного сервера
репозитория, представляющего собой простую объектно-ориентированную
СУБД. При этом клиент репозитория должен инкапсулировать в себе всю
требуемую информацию для осуществления взаимодействия с удаленным
сервером и предоставлять всем остальным компонентам системы доступ к
данным посредством фиксированного API. 

Первоначально общение между клиентом и сервером репозитория
осуществлялось с помощью текстового протокола поверх
TCP/IP, однако с появлением первых генераторов CASE-пакета
была поставлена задача поддержки протокола более высокого уровня. Это
объяснялось тем, что первые генераторы писались на языке
C\# под платформу .NET, а клиент репозитория --- на языке
C++ с обширным использованием возможностей
инструментария Qt. Поэтому удачным, на наш
взгляд, решением проблемы организации взаимодействия этих компонент
явилось внедрение высокоуровневого RPC
протокола взаимодействия клиента и сервера репозитория --- таким образом,
для каждого языка/платформы этот интерфейс необходимо реализовать
только один раз. В качестве такого протокола был выбран
ZeroC ICE~\cite{ice}.

\subsection{Замена формата SVG}

Еще одной проблемой созданного прототипа было масштабирование
графических изображений элементов на диаграммах. Для задания
представлений элементов использовался формат SVG, что позволяло быстро
создавать векторные изображения и обрабатывать их стандартными
средствами модуля QtSvg (в Qt реализована поддержка
SVG 1.2 Tiny\footnote{http://www.w3.org/TR/SVGMobile12/}). 
Однако, изображения векторной графики при масштабировании
изменяют свои размеры и толщину линий пропорционально растяжению всей
фигуры, что приводило к ситуациям, проиллюстрированным на рис.~\ref{scaling}.

\begin{figure} [ht]
  \begin{center}
    \includegraphics[width=0.5\textwidth, bb=0 0 544 390]{draft04-img3.jpg}
    \caption{Элемент до (слева) и после (справа) масштабирования}
    \label{scaling}
  \end{center}
\end{figure}

Пользоваться такими фигурами было неудобно, а так как формат
SVG не предоставляет средств для его
расширения, была поставлена задача создания собственного языка описания
графических представлений элементов на замену SVG (и, соответственно,
реализация средств отрисовки изображений, описанных с помощью этого
языка). Основными требованиями к нему стали стала поддержка
дифференцированного масштабирования элементов --- возможность при
описании элемента задавать тип масштабирования составляющих его частей.
В результате был создан язык SDF (stencil description format) и
средства его отрисовки, которые поддерживают два вида масштабирования:

\begin{itemize}
  \item Абсолютное --- размер графического примитива задается в явном виде и при
        масштабировании не меняется;\newline
    \includegraphics[width=0.7\textwidth, bb=0 0 1152 656]{draft04-img4.jpg}
  \item Процентное --- размер графического примитива задается в процентах от
        общего размера элемента (сюда же входит и <<обычное>> пропорциональное
        масштабирование).\newline
    \includegraphics[width=0.7\textwidth, bb=0 0 1152 659]{draft04-img5.jpg}
\end{itemize}

Кроме того, были созданы средства конвертации SVG-описаний в формат SDF
для преобразования большого числа уже имеющихся SVG-изображений
элементов. К тому же, мы получили гибкий формат, который можно быстро
изменять под свои дальнейшие нужды.

\subsection{Выделение логической модели}

В результате работы над QReal возникло более ясное понимание того,
как модели должны храниться в репозитории и отображаться в пользовательском
интерфейсе. Проблема, общая для всех CASE-систем, состоит в том, что 
было бы удобно иметь хорошо выраженную логическую модель разрабатываемой системы, 
с которой 
удобно работать генераторам кода, и при этом иметь возможность в процессе 
моделирования рассматривать моделируемую систему с различных точек зрения.
К примеру, модель некоторой системы может содержать диаграммы конечных 
автоматов, описывающие поведение каких-либо классов, и диаграммы последовательности, 
которые описывают некоторые сценарии взаимодействия объектов этих классов.
Естественно, такая модель может содержать избыточную информацию, 
которую необходимо автоматически поддерживать согласованной.

Поэтому имеет смысл явно разделить модель на логическую и графическую составляющие.
При этом одной логической сущности может соответствовать несколько (или ни одного) 
графических представлений. Представления имеют атрибуты, относящиеся непосредственно к графике, 
как то положение, размеры, форма, цвет, отображать ли поля/методы и т.д. 
Все существенные с точки зрения логики модели атрибуты (поля, методы, ассоциации и т.д.) 
хранятся в логической сущности и только отображаются представлениями. Это полезно для 
поддержания консистентности, поскольку, меняя существенные атрибуты одного представления 
логической сущности, мы меняем саму логическую сущность, 
автоматически меняя тем самым остальные её представления. 

Сущности логической и графической модели взаимосвязаны следующим образом.
\begin{itemize}
  \item Элемент графической модели может иметь один прототип --- логическую сущность 
    (<<обычные>> элементы) или не иметь прототипа --- специальные графические сущности, 
    предназначенные для группировки графических элементов, аннотации диаграмм, рисования и т.д. 
    Пример такого представления, не имеющего логического прообраза --- диаграмма (как элемент графической модели).
    Диаграмма может рассматриваться как способ группировки графических элементов
    и не должна быть видна генераторам (которые, как правило, используют для группировки пакеты).
  \item Один элемент логической модели может иметь ноль или больше представлений. 
    Представления могут не только иметь разные параметры отображения, но и вообще задаваться 
    разными фигурами и иметь разный набор <<существенных>> атрибутов. Элемент логической модели 
    можно представить как объединение существенных атрибутов всех его возможных представлений (существенными
    атрибутами представления здесь называются атрибуты логической сущности, 
    с которыми пользователь может взаимодействовать через представление).
  \item Связи между элементами логической модели довольно просты --- отношение <<родитель-сын>>
    (точнее, <<контейнер-элемент>>) и ссылки на другие объекты или ассоциации. В графической модели
    связи между элементами могут отражать способ визуальной группировки элементов и могут
    быть довольно сложными --- <<родитель-сын>> (один элемент может находиться внутри другого
    и, например, перемещаться по диаграмме как единое целое), <<встроенный>> элемент, имеющий
    фиксированную внутри элемента-родителя позицию (например, метод в классе) и прочие виды связей,
    которые могут задаваться, например, графическими грамматиками \cite{koznov}.
  \item Хранить в репозитории необходимо отдельно логическую и графическую части модели.
    Выделение графических представлений в отдельные сущности репозитория полезно для 
    организации многопользовательской работы, поскольку в этом случае изменение
    графических свойств какого-либо представления может быть осуществлено независимо от
    логической сущности, а значит, с меньшей вероятностью приведёт к конфликту.
  \item В пользовательском интерфейсе должны отображаться обе части модели (например, в виде
    двух отдельных деревьев), при этом должна быть обеспечена синхронность вносимых изменений.
\end{itemize}

\subsection{Метаредактор}

Долгое время XML-описания редакторов в системе  QReal писались вручную, однако,
сами XML-описания можно рассматривать как целевой текстовый язык для генерации
из визуальной модели. Для этого в QReal был создан ещё один графический редактор
(метаредактор, т.е. редактор графических редакторов).
По сути, метаредактор предоставляет пользователям визуальный язык, являющийся подмножеством
стандартного языка MOF (Meta Object Facility)~\cite{mof} , на котором описываются все
метамодели, например, метамодель UML. Практика показывает, что достаточно реализовать лишь
небольшой набор элементов MOF: 

\begin{itemize}
  \item классы (задают множество элементов конкретного типа);
  \item ассоциации между ними (например, для задания отношения наследования);
  \item атрибуты классов (например, используемые для задания свойств элементов
        заданного типа).
\end{itemize}

На данный момент нам кажется, что этих сущностей достаточно, чтобы
описать метамодели всех возможных редакторов, поддерживаемых нашим
CASE-средством. Метаредактор был создан в достаточно короткое время,
что подтвердило эффективность предлагаемого генеративного подхода
к созданию редакторов.

\section*{Заключение}

В статье описаны подходы к созданию среды визуального моделирования, опыт их
апробации и сформированная на их основе архитектура такой среды. Представленная
архитектура была реализована на уровне прототипа в пакете QReal, разработанном на
кафедре системного программирования математико-механического факультета СПбГУ. 

В качестве основных проблем, возникающих при реализации систем такого класса, были
выделены следующие:
\begin{itemize}
	\item Выбор способа хранения создаваемых пользователями моделей, с учетом
	  требований по обеспечению многопользовательской работы, поддержки
	  версионирования и ссылочной целостности. Реляционные базы данных,
	  представляющиеся наиболее естественным кандидатом на эту роль, оказываются 
	  недостаточно эффективны в данном случае в силу указанных в работе специфических
	  требований.
	\item Отделение логической модели от ее графического представления на диаграммах.
	\item Разработка набора графических примитивов и способа конструирования из них
	  элементов диаграмм, позволяющих достаточно полно реализовывать различные
    диаграммы.
\end{itemize}

В настоящий момент работа над QReal продолжается, соответственно, продолжается и
поиск эффективных решений возникающих при этом проблем, в том числе и обсуждаемых в
данной статье.

\pagebreak

  \begin{thebibliography}{99}
  \bibitem {umlInfrastructure} OMG Unified Modeling Language (OMG UML), Infrastructure, Version 2.2, OMG, 2009.
    URL: http://www.omg.org/spec/UML/2.2/Infrastructure/PDF
  \bibitem {umlSuperstructure} OMG Unified Modeling Language (OMG UML), Superstructure, Version 2.2, OMG, 2009.
    URL: http://www.omg.org/spec/UML/2.2/Superstructure/PDF
  \bibitem {bpmn} Business Process Modeling Notation. Final Notation Specification dtc/06-02-01, OMG, 2006.
    URL: http://www.omg.org/spec/BPMN/1.2/PDF
  \bibitem {idef} Семейство стандартов Integration DEFinition, http://www.idef.com/.  
  \bibitem{koznov} Кознов Д.В., Основы визуального моделирования, БИНОМ. Лаборатория знаний, Интернет-университет информационных технологий - ИНТУИТ.ру, 2008.
  \bibitem{koznovDsl} Кознов Д.В., Ольхович Л.Б., Визуальные языки проектов. // Системное программирование. Вып. 1: Сб. статей / Под ред. А.Н.Терехова, Д.Ю.Булычева. --- СПб.: 2004, с. 148-167,
  \bibitem{amln} Thomas G. Muth, Functional Structures in Networks, Springer, 2005.
  \bibitem{eclipseGmf} http://www.eclipse.org/modeling/gmf/.  
  \bibitem{msDslTools} http://msdn.microsoft.com/en-us/library/bb126235.aspx.
  \bibitem {metaEdit+} 	Steven Kelly, Kalle Lyytinen, Matti Rossi, MetaEdit+: A Fully Configurable Multi-User and
    Multi-Tool CASE and CAME Environment // Proceedings of the 8th International Conference on Advances Information System 
    Engineering, pp. 1-21, 1996.
  \bibitem {qt} http://www.qtsoftware.com/.  
  \bibitem{bryksin} Брыксин Т.А., Model/View-архитектура CASE-пакета REAL-MV, дипломная работа, 2007, URL: http://unreal.tepkom.ru/trac/attachment/wiki/Diplomes/ Bryksin\_Diploma.doc.
    http://www.sysprog.info/2004/08.pdf. 
  \bibitem {odmg} The Object Data Management Standard: ODMG 3.0, Edited by R. G.G. Cattell, Douglas K. Barry, Mark Berler, 
    et al., Morgan Kaufmann, 2000, ISBN 1-55860-647-5
  \bibitem{kondratyev} Кондратьев А.М., CASE-средства и объектные базы данных, Объектно-ориентированное визуальное моделирование / Под ред. Проф. Терехова А.Н. -- СПб: Издательство С.Петербургского университета, 1999. C.57-78.
  \bibitem{nikandrov} Никандров Г., Реализация кроссплатформенной архитектуры CASE-пакета, дипломная работа, 2007, URL: http://unreal.tepkom.ru/trac/attachment/wiki/Diplomes/\newline Nikandrov\_Diploma.pdf. 
  \bibitem{simonova} Симонова А.А., Подход к разработке CASE-пакетов, дипломная работа, 2007, URL: http://unreal.tepkom.ru/trac/attachment/wiki/Diplomes/\newline Simonova\_Diploma.doc.
  \bibitem{real1} Иванов А., Кознов Д., Лебедев А., Мурашева Т., Парфенов В., Терехов А. Объектно-ориентированное расширение технологии RTST. // Записки семинара кафедры системного программирования <<CASE-средства RTST++>>. Вып. 1. - CПб, Изд-во С.-Пб ун-та, 1998. С. 17-36.
  \bibitem{real2} Терехов А.Н., Романовский К.Ю., Кознов Д.В., Долгов П.С., Иванов А.Н., REAL: методология и CASE-средство для разработки систем реального времени и информационных cистем, Программирование, 1999, № 5. C. 44-52.
  \bibitem {sdl}  ITU-T Recommendation Z.100: Specification and Description Language. 1993. 204 p.
  \bibitem {realIt} Ivanov A., D.Koznov. REAL-IT: Model-BASED User Interface Development 
      Environment. Proceedings of IEEE/NASA ISoLA 2005 Workshop on Leveraging 
      Applications of Formal Methods, Verification, and Validation. 
      Loyola College Graduate Center Columbia, Maryland, USA, 23-24 September 
      2005. P. 31-41. http://real.tercom.ru/.
  \bibitem{gme} Akos Ledeczi, Miklos Maroti, Arpad Bakay et al., The Generic Modeling Environment, published in the Proceedings of WISP'2001, May, 2001.
  \bibitem{ice} The Internet Communications Engine, ZeroC Inc., 2009, URL: http://www.zeroc.com/ice.html.
  \bibitem{mof} Meta Object Facility (MOF) Core Specification, Version 2.0, Object Management Group, 2006, URL: http://www.omg.org/spec/MOF/2.0/.
  \bibitem{svgTiny} Mobile SVG Profiles: SVG Tiny and SVG Basic, The World Wide Web Consortium, 2003, URL: http://www.w3.org/TR/SVGMobile/.
  \bibitem{htmlInQt} Supported HTML Subset, документация библиотеки Qt, Nokia Corporation, 2009, URL: http://doc.trolltech.com/4.5/richtext-html-subset.html.
  
\end{thebibliography}

\end{document}
